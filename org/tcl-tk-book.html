<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-02-08 Чт 21:36 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Глава 7. Процедуры и область видимости</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Глава 7. Процедуры и область видимости</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5473cca">1. 0</a></li>
<li><a href="#org8088e66">2. Команда рrос</a></li>
<li><a href="#orgecec180">3. Изменение имен команд с помощью команды rename</a></li>
<li><a href="#orgf7e9e7e">4. Область видимости</a></li>
<li><a href="#orgf34078f">5. Команда global</a></li>
<li><a href="#orgaa59e6e">6. Передача имени с помощью команды upvar</a></li>
<li><a href="#org8e26301">7. Создание псевдонимов с помощью команды upvar</a></li>
<li><a href="#orgfb83343">8. <span class="todo TODO">TODO</span> Использование команды upvar для поддержки состояния объектов</a></li>
</ul>
</div>
</div>
<div id="outline-container-org5473cca" class="outline-2">
<h2 id="org5473cca"><span class="section-number-2">1.</span> 0</h2>
<div class="outline-text-2" id="text-1">
<p>
  Процедуры содержат наборы команд. С ними же связано понятие 
области видимости переменных. В данной главе рассматриваются 
команды proc, global и upvar.
</p>

<p>
  Процедуры позволяют организовать выполнение набора команд с  
заданными значениями параметров. Каждая процедура создает новую область  
видимости для переменных. Область видимости переменной — это множество 
команд, которым доступна данная переменная. Первоначально в Tcl была 
определена одна глобальная область видимости для общедоступных  
переменных, локальные области видимости в пределах процедур и одна глобальная 
область видимости для процедур. В Tcl 8.0 был введен механизм  
пространства имен, посредством которого реализуются новые области видимости для 
процедур и глобальных переменных. При создании простых программ  
разработчики обычно не используют пространства имен и ограничиваются  
глобальной областью видимости. Новые средства находят применение лишь при 
написании сложных приложений. Пространства имен будут подробно  
обсуждаться в главе 14.
</p>
</div>
</div>

<div id="outline-container-org8088e66" class="outline-2">
<h2 id="org8088e66"><span class="section-number-2">2.</span> Команда рrос</h2>
<div class="outline-text-2" id="text-2">
<p>
  Для определения процедуры в Tcl используется команда ргос. Ей  
передаются три параметра:
</p>
<pre class="example">
ргос имя список_параметров тело_процедуры
</pre>

<p>
  Первый параметр задает имя процедуры. Оно добавляется к набору  
команд, которые могут быть выполнены интерпретатором Tcl. В имени  
процедуры могут содержаться практически любые символы; регистр символов 
имеет значение. Имена процедур не конфликтуют с именами переменных. 
В качестве второго параметра команды pro с задается список параметров  
процедуры. Последним параметром команды является тело процедуры. 
</p>

<p>
  Единожды определенная, Tcl-процедура может использоваться точно так 
же. как и встроенная команда Tcl. При вызове процедуры параметрам  
ставятся в соответствие переданные значения и выполняется тело процедуры. 
Возвращаемый результат определяет последняя команда в теле процедуры. 
Если необходимо, чтобы процедура возвращала другое значение, надо  
использовать команду return. 
</p>

<p>
  Процедуры позволяют определять параметры по умолчанию. При  
вызове подобной процедуры некоторые параметры можно не указывать.  
Определение параметра по умолчанию предполагает указание имени и значения. 
Пример определения таких параметров приведен в листинге 7.1.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Листинг 7.1. Значения параметров по умолчанию</label><pre class="src src-tcl" id="org6424190">proc P2 {а {Ь 7} {с -2} } { 
expr $а / $Ь + $с 
} 
Р2 6 3 
=&gt; 0 
</pre>
</div>

<p>
  В данном примере процедура Р2 может быть вызвана с указанием одного, 
двух либо трех параметров. Если при вызове процедуры задан лишь один  
параметр, значения b и с принимаются такими, какие были заданы в команде 
ргос. Если при вызове процедуры указаны два параметра, значение по  
умолчанию получит только с. Меньше одного и больше трех параметров передать 
процедуре Р2 невозможно. 
</p>

<p>
  Для того чтобы процедуру можно было вызывать с указанием  
произвольного числа параметров, надо в качестве последнего параметра указать  
ключевое слово args. При вызове процедуры args представляет список,  
содержащий все остальные параметры.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Листинг 7.2. Вызов процедуры с произвольным числом параметров</label><pre class="src src-tcl" id="org148afb4">proc ArgTest {a {b foo} args} { 
foreach param {a b args} { 
puts stdout "\t$param = [set $param]" 
set х one 
set у {two things} 
set z \[special\$ 
ArgTest $x 
=&gt; a = one 
b = foo 
args = 
ArgTest $y $z 
=&gt; a = two things 
b = [special$ 
args = 
ArgTest $x $y $z 
=&gt; a = one 
b = two things 
args = {[special$} 
ArgTest $z $y $z $x 
=&gt; a = [special$ 
b = two things 
args = {[special$} one 
</pre>
</div>

<p>
  Переменная z в листинге 7.2 демонстрирует работу со списком при  
использовании ключевого слова args. Как видно в листинге, значение  
переменной z содержит специальный символ. Когда $z указывается в качестве 
параметра Ь, значение этой переменной передается процедуре в неизменном 
виде. Если $z входит в состав необязательных параметров, осуществляется 
автоматическая группировка, в результате чего значением args становится 
корректный список. Способ, позволяющий отменить формирование списка, 
будет показан в листинге 10.3.
</p>
</div>
</div>

<div id="outline-container-orgecec180" class="outline-2">
<h2 id="orgecec180"><span class="section-number-2">3.</span> Изменение имен команд с помощью команды rename</h2>
<div class="outline-text-2" id="text-3">
<p>
  Команда rename позволяет изменять имена других команд. Как правило,
rename используется для выполнения двух задач. Первая из них — это
модификация существующих процедур. Перед тем как переопределить
процедуру, вы можете переименовать ее.
</p>
<div class="org-src-container">
<pre class="src src-tcl">rename foo foo.orig
</pre>
</div>

<p>
  В новую реализацию foo вы можете включить вызов foo.orig. В  
результате пользователи foo начнут работать с новой версией команды, причем они 
могут даже не заметить этого. 
</p>

<p>
  Команду rename можно также использовать для удаления других команд.
Команда, подлежащая удалению, переименовывается, а в качестве нового
имени указывается пустая строка. Предположим, например, что вы не
хотите, чтобы пользователи вызывали другие Unix-программы. Для этого
можно удалить команду exec с помощью следующего выражения:
</p>
<div class="org-src-container">
<pre class="src src-tcl">rename exec {} 
</pre>
</div>

<p>
  Переименование и удаление команд можно отследить с помощью команды
trace, которая описывается в главе 13.
</p>
</div>
</div>
<div id="outline-container-orgf7e9e7e" class="outline-2">
<h2 id="orgf7e9e7e"><span class="section-number-2">4.</span> Область видимости</h2>
<div class="outline-text-2" id="text-4">
<p>
  По умолчанию в Tcl-программах для имен процедур используется одна 
глобальная область видимости. Это означает, что любая процедура может 
быть вызвана в любой позиции сценария. Переменные, определенные за  
пределами процедур, являются глобальными. Однако, несмотря на их название, 
глобальные переменные не обязательно доступны внутри процедуры. Для  
переменных и процедур могут быть определены различные пространства имен, 
что позволяет создавать глобальные переменные и процедуры с  
одинаковыми именами, не вызывая конфликта. Используя механизм пространств имен, 
рассмотренный в данной главе, вы можете эффективно управлять  
процедурами и переменными. 
</p>

<p>
  В каждой процедуре создается локальная область видимости для  
переменных. Время жизни переменных, определенных в процедуре, ограничено 
временем выполнения этой процедуры. После завершения процедуры  
локальные переменные становятся неопределенными. Переменные, определенные за 
пределами процедуры, видимы только в случае применения команды upvar 
или global. Для обращения к переменным в некоторой области видимости 
вы можете использовать полностью определенные имена этих переменных. 
Команды global и upvar будут рассмотрены ниже. Полностью  
определенные имена обсуждаются в главе 14. Наличие в разных областях видимости 
переменных с одинаковыми именами не становится причиной конфликта. 
</p>

<p>
  В листинге 7.3 переменная а в глобальной области видимости не  
конфликтует с одноименным параметром процедуры Р1. Аналогично, глобальная  
переменная b отличается от локальной переменной b в составе Р1. 
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Листинг 7.3. Область видимости и Тс1-процедура</label><pre class="src src-tcl" id="org2a7c04d">set a 5 
set b -8 
proc P1 {а} { 
set b 42 
if {$a &lt; 0} { 
return $b 
} else { 
return $a 
} 
} 
PI $b 
=&gt; 42 
PI [expr {$a*2}] 
=&gt; 10 
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf34078f" class="outline-2">
<h2 id="orgf34078f"><span class="section-number-2">5.</span> Команда global</h2>
<div class="outline-text-2" id="text-5">
<p>
  Глобальная область видимости — это область видимости верхнего
уровня.  Данная область лежит за пределами всех процедур. Переменные,
определенные в глобальной области, становятся доступными в процедуре
посредством команды global. Эта команда вызывается следующим образом:
</p>
<div class="org-src-container">
<pre class="src src-tcl">global имя_переменной_1 имя_переменной_2 ...
</pre>
</div>

<p>
Команда global вызывается внутри процедуры.
</p>

<p>
  Она добавляет глобальную переменную к текущей области  
видимости. Некоторые неопытные программисты считают, что  
единожды вызванная команда global применима ко всем процедурам. 
Это неверно. Команда global, вызванная в глобальной области  
видимости, не даст никакого эффекта. Данную команду надо  
указывать в каждой процедуре, в которой необходимо обеспечить доступ 
к глобальной переменной. В момент вызова команды global  
переменная не обязательно должна быть определена. Если же  
переменная определена, она становится видимой в глобальной области  
видимости.
</p>


<p>
  В листинге 7.4 приведен код генератора случайных чисел. Однако, перед 
тем как перейти к рассмотрению примера, следует заметить, что наилучший 
способ получения в Tcl-сценарии последовательности случайных чисел — это 
вызов функции rand().
</p>
<div class="org-src-container">
<pre class="src src-tcl">expr rand() 
=&gt; .137287362934 
</pre>
</div>

<p>
  При работе с генератором случайных чисел надо поддерживать
переменную состояния, содержащую начальное значение. Эта переменная не
должна изменяться между вызовами функции генератора. В рассматриваемом
примере роль переменной состояния играет randomSeed. Правильно выбрать
имя очень важно. Это позволит избежать конфликтов с другими частями
программы. В примере, представленном в листинге 14.1, для ограничения
доступа к переменной состояния используется пространство имен.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Листинг 7.4. Генератор случайных чисел</label><pre class="src src-tcl" id="org00b28e0">proc Randomlnit { seed } { 
global randomSeed 
set randomSeed $seed 
} 
proc Random {} { 
global randomSeed 
set randomSeed [expr ($randomSeed*9301 + 49297) % 233280] 
return [expr $randomSeed/double(233280)] 
} 
proc RandomRange { range } { 
expr int([Random]*$range) 
} 
Randomlnit [pid] 
=&gt; 5049 
Random 
=&gt; 0.517686899863 
Random 
=&gt; 0.217176783265 
RandomRange 100 
=&gt; 17 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaa59e6e" class="outline-2">
<h2 id="orgaa59e6e"><span class="section-number-2">6.</span> Передача имени с помощью команды upvar</h2>
<div class="outline-text-2" id="text-6">
<p>
  Если вам надо передать процедуре не значение, а имя переменной, вы 
можете использовать для этой цели команду upvar. Данная команда  
связывает локальную переменную с переменной в области видимости, находящейся 
выше по стеку вызовов. Команда upvar записывается следующим образом:
</p>
<div class="org-src-container">
<pre class="src src-tcl">upvar ?уровень? имя_переменной локальная_переменная
</pre>
</div>

<p>
  Первый параметр команды не является обязательным. По умолчанию 
принимается значение 1, что соответствует перемещению вверх по стеку  
вызовов на один уровень. Вы можете указать другое число кадров для  
перемещения или задать абсолютный номер кадра с помощью выражения #число. 
Уровню #0 соответствует глобальная область видимости, поэтому команда
</p>
<div class="org-src-container">
<pre class="src src-tcl">global fоо
</pre>
</div>
<p>
эквивалентна следующему выражению: 
</p>
<div class="org-src-container">
<pre class="src src-tcl">upvar #0 foo foo 
</pre>
</div>

<p>
  Переменная в кадре может быть скалярной переменной, элементом  
массива или именем массива. В первых двух случаях локальная переменная  
интерпретируется как скалярная. В случае имени массива локальная переменная 
рассматривается как массив. Использование команды upvar и массивов будет 
подробно рассмотрено в главе 8. В процедуре, приведенной в листинге 7.5, 
upvar используется для вывода значения переменной по ее имени.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>Листинг 7.5. Вывод переменной по имени</label><pre class="src src-tcl" id="org546717f">proc PrintByName { varName } { 
upvar 1 $varName var 
puts stdout "$varName = $varM 
} 
</pre>
</div>
<p>
  Команду upvar можно использовать для модификации команды incr.
Встроенная команда incr обладает существенным недостатком: она
порождает ошибку, если переменная отсутствует. В качестве примера
рассмотрим новую версию incr, которая инициализирует отсутствующую
переменную.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>Листинг 7.6. Модифицированная команда incr</label><pre class="src src-tcl" id="org75ed388">proc incr { varName {amount 1}} { 
upvar 1 $varName var 
if {[info exists var]} { 
set var [expr $var + $amount] 
} else { 
set var $amount 
} 
return $var 
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org8e26301" class="outline-2">
<h2 id="org8e26301"><span class="section-number-2">7.</span> Создание псевдонимов с помощью команды upvar</h2>
<div class="outline-text-2" id="text-7">
<p>
  Команда upvar полезна тогда, когда имя одной переменной хранится в
другой переменной. В коде, приведенном в листинге 7.2, переменной
цикла param присваиваются имена других неременных. Их значения
извлекаются с помощью следующего выражения:
</p>
<div class="org-src-container">
<pre class="src src-tcl">puts stdout "\t$param = [set $param]"
</pre>
</div>

<p>
  Сделать то же самое можно с помощью команды upvar. При этом исчезает 
необходимость в использовании неудобных конструкций типа [set $param]. 
Если переменная находится в той же области видимости, то команде upvar 
надо передать номер уровня 0. Приведенные ниже команды выполняют такие 
же действия, как и предыдущее выражение.
</p>

<p>
upvar 0 $param x 
puts stdout "\t$param = $х"
</p>
</div>
</div>
<div id="outline-container-orgfb83343" class="outline-2">
<h2 id="orgfb83343"><span class="section-number-2">8.</span> <span class="todo TODO">TODO</span> Использование команды upvar для поддержки состояния объектов</h2>
<div class="outline-text-2" id="text-8">
<p>
  Предположим, что ваша программа поддерживает информацию о  
состоянии набора объектов: файлов, Web-документов и др. Имя объекта можно 
использовать как имя переменной, в которой хранится информация о  
состоянии. Сделать это удобно с помощью команды upvar. 
upvar #0 $name state 
Однако непосредственно использовать имя объекта несколько  
рискованно. Если, например, у нас есть объект с именем х, то может возникнуть  
конфликт с переменной х, расположенной в другом месте программы. Для того 
чтобы описанный подход обеспечивал более высокую надежность, имя надо 
модифицировать. 
upvar #0 state$name state 
В этом случае имя выполняет роль дескриптора объекта, а команда upvar 
предоставляет доступ к связанным с ним данным. Код, выполняющий  
обработку, использует псевдоним переменной состояния текущего объекта. Более 
подробно данный подход будет рассматриваться в главе 17. В частности,  
конкретный пример представлен в листинге 17.7. 
Пространства имен и команда upvar 
Команда upvar может использоваться также для создания псевдонимов 
к переменным пространств имен. Пространства имен будут подробно  
обсуждаться в главе 14. Например, вместо того чтобы резервировать глобальные 
переменные, начинающиеся со слова state, для специальных целей, вы  
можете запретить к ним доступ помощью пространства имен. 
upvar #0 state::$name state 
В данном случае state представляет собой псевдоним переменной.  
Благодаря команде upvar появляется возможность работать с любым  
пространством имен. 
Глава 7. Процедуры и область видимости 
171 
Команды, работающие с именами переменных 
Некоторые Tcl-команды предназначены для обработки имен переменных. 
Например, компоненты Tk могут быть связаны с глобальными переменными 
Tcl. Имена переменных передаются в качестве параметров командам vwait 
и tkwait. 
Команда upvar не позволяет создавать псевдонимы для текстовых 
компонентов Тк. 
Псевдонимы, созданные с помощью upvar, неприменимы к  
указанным выше командам. Они также не будут работать, если  
используется команда trace, рассматриваемая в главе 13. В этих  
случаях вы должны указывать реальные имена глобальных переменных. 
Продолжая разговор о примере, в котором state используется как 
псевдоним, заметим, что следующие две команды некорректны: 
vwait state(foo) 
button .b -textvariable state(foo) 
Вместо них должны использоваться такие выражения: 
vwait state$name\(foo) 
button .b -textvariable state$name\(foo) 
Символ обратной косой черты отменяет ссылку на массив, поэтому в Tcl- 
сценариях не следует пытаться использовать name в качестве массива. Не  
следует беспокоиться о наличии в $name специальных символов, за исключением 
круглых скобок. Как только имя будет передано компоненту Тк, оно будет 
непосредственно использоваться как имя переменной. Текстовые переменные 
для меток рассматриваются в главе 32, а переменные для полей  
редактирования —- в главе 34. </p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-02-08 Чт 21:36</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
