<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-02-06 Вт 21:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Глава 8. Массивы Tcl</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Глава 8. Массивы Tcl</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org6c3b2b5">1. 0</a>
<ul>
<li><a href="#org62741c2">1.1. Языковые средства для работы с массивами</a></li>
<li><a href="#orgf40c890">1.2. Индексы</a></li>
<li><a href="#orga90a518">1.3. Переменные массивов</a></li>
</ul>
</li>
<li><a href="#orgad7c940">2. Команда array</a>
<ul>
<li><a href="#org17f7aa3">2.1. Преобразование массивов в списки</a></li>
<li><a href="#org62ee344">2.2. Передача имен массивов</a></li>
</ul>
</li>
<li><a href="#org1b97858">3. Создание структур данных на базе массивов</a>
<ul>
<li><a href="#orgc01fa51">3.1. 0</a></li>
<li><a href="#org30c5ecf">3.2. Простые записи</a></li>
<li><a href="#orgd423732">3.3. Стек</a></li>
<li><a href="#org60c09e4">3.4. Список массивов</a></li>
<li><a href="#org3f1ff60">3.5. Простая база данных</a></li>
<li><a href="#orgc35e8ae">3.6. Альтернативы использованию массивов</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6c3b2b5" class="outline-2">
<h2 id="org6c3b2b5"><span class="section-number-2">1.</span> 0</h2>
<div class="outline-text-2" id="text-1">
<p>
  В данной главе описываются массивы Tcl, на базе которых можно
создавать многие другие структуры данных. Из команд здесь
рассматривается только array.
</p>

<p>
  В языке Tcl массив — это переменная, предполагающая наличие  
индекса. Индексом в данном случае является строковое значение. Индекс можно 
рассматривать как ключ, а массив — как набор данных, элементы которых 
идентифицируются с помощью ключей. В качестве индекса допустима любая 
строка. В составе Tcl массив представлен в виде хэш-таблицы, в результате 
чего накладные расходы, возникающие при обращении к элементу массива, 
практически не зависят от характеристик этого элемента. В версиях,  
предшествующих Tcl 8.O. массивы обеспечивали более высокую производительность, 
чем списки, так как время доступа к элементу списка было пропорционально 
длине списка.
</p>

<p>
Массивы — гибкий инструмент, поэтому они очень часто используются 
при создании Tcl-нрограмм. Как привило, массивы применяются для  
организации набора переменных, подобно структурам в языке С и записям в  
Pascal. В данной главе мы рассмотрим некоторые простые структуры данных, 
создаваемые с использованием массивов. 
</p>
</div>

<div id="outline-container-org62741c2" class="outline-3">
<h3 id="org62741c2"><span class="section-number-3">1.1.</span> Языковые средства для работы с массивами</h3>
<div class="outline-text-3" id="text-1-1">
<p>
  Для выделения индекса массива используются круглые скобки. Индекс
представляет собой произвольное строковое значение и может
формироваться путем подстановки переменной или команды. Для
формирования элементов массива используется команда set.
</p>
<div class="org-src-container">
<pre class="src src-tcl">set arr(индекс) значение 
</pre>
</div>

<p>
Значение элемента массива извлекается с помощью подстановки,  
выполняемой при указании символа $.
</p>
<div class="org-src-container">
<pre class="src src-tcl">set foo $arr(индекс) 
</pre>
</div>

<p>
В листинге 8.1 в качестве индекса используется значение переменной  
цикла $i. В результате выполнения приведенного кода каждому элементу  
массива агг(х) присваивается значение 1 * 2 * &#x2026; * х.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Листинг 8.1. Пример использования массива</label><pre class="src src-tcl">set arr(0) 1
for {set i 1} {$i &lt;= 10} {incr i} {
    set arr($i) [expr {$i * $arr([expr {$i-1}])}] 
} 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf40c890" class="outline-3">
<h3 id="orgf40c890"><span class="section-number-3">1.2.</span> Индексы</h3>
<div class="outline-text-3" id="text-1-2">
<p>
  Индексом массива может быть любая строка, например orange, 5, 3.1415, 
foo, bar и т.д. В примерах, приведенных в данной главе и далее в книге, для 
создания гибких структур данных используются индексы массивов,  
представляющие собой достаточно большие строки символов. Несмотря на то что  
индексом может быть любая строка, следует избегать использования в качестве 
индексов строк, содержащих пробелы.
</p>

<p>
Круглые скобки не осуществляют группировку.
</p>

<p>
  Основной синтаксический анализатор Tcl "не осведомлен" о правилах
создания массивов. Принципы группировки и подстановки, описанные в
главе 1, учитываются при работе с массивами так же, как и при
использовании обычных команд. В отличие от фигурных скобок и кавычек,
круглые скобки не осуществляют группировку, по этой причине могут
возникать проблемы, связанные с наличием пробелов. При использовании
составного индекса разделяйте различные его части с помощью
запятых. Если же в индексе используется пробел, то перед ним надо
указывать обратную косую черту либо осуществлять группировку.
</p>
<div class="org-src-container">
<pre class="src src-tcl">set {arr(I'm asking for trouble)} {I told you so.} 
set arr(Pm\ asking\ for\ trouble) {I told you so.} 
</pre>
</div>

<p>
  Если индекс массива хранится в переменной, наличие пробелов в ее  
значении не играет роли. Оба приведенных ниже выражения корректны. 
</p>
<div class="org-src-container">
<pre class="src src-tcl">set index {I'm asking for trouble} 
set arr($index) {I told you so.} 
</pre>
</div>
</div>
</div>

<div id="outline-container-orga90a518" class="outline-3">
<h3 id="orga90a518"><span class="section-number-3">1.3.</span> Переменные массивов</h3>
<div class="outline-text-3" id="text-1-3">
<p>
  Элементы массива можно использовать как обычные переменные.  
Например, вы можете проверять их наличие с помощью команды info exists, ин- 
крементировать значение посредством команды incr и добавлять элементы, 
используя команду lappend.
</p>
<div class="org-src-container">
<pre class="src src-tcl">if {[info exists stats($event)]} {incr stats($event)} 
</pre>
</div>

<p>
  По мере необходимости можно удалить с помощью команды unset весь
массив или один его элемент. Применение команды unset к массиву —
удобный способ очищать большие структуры данных.
</p>

<p>
  Одну и ту же переменную нельзя одновременно использовать как обычную
переменную и как массив. Приведенное ниже сочетание команд
недопустимо.
</p>
<div class="org-src-container">
<pre class="src src-tcl">set arr(0) 1
set arr 3 
=&gt; can't set "arr": variable is array 
</pre>
</div>

<p>
  Имя массива может формироваться как результат подстановки. Такой
подход использовался в примере, приведенном в листинге 8.2.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Листинг 8.2. Косвенное обращение к массиву</label><pre class="src src-tcl" id="org4894cbc">set name TheArray 
=&gt; TheArray 
set ${name}(xyz) {some value} 
=&gt; some value 
set x $TheArray(xyz) 
=&gt; some value 
set x ${name}(xyz) 
=&gt; TheArray(xyz) 
set x [set ${name}(xyz)] 
=&gt; some value 
</pre>
</div>

<p>
  Аналогичные результаты можно получить, используя команду upvar,
которая была описана в главе 7. Если переписать предыдущий пример,
применяя команду upvar, код станет более понятным.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Листинг 8.3. Косвенное обращение к массиву с использованием команды upvar</label><pre class="src src-tcl" id="org7836bf1">set name TheArray 
=&gt; TheArray 
upvar 0 $name a 
set a(xyz) {some value} 
=&gt; some value 
set x $TheArray(xyz) 
=&gt; some value 
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgad7c940" class="outline-2">
<h2 id="orgad7c940"><span class="section-number-2">2.</span> Команда array</h2>
<div class="outline-text-2" id="text-2">
<p>
  Команда array возвращает информацию о переменных массива. В  
результате выполнения команды array names возвращаются имена индексов, 
определенных в массиве. Если переменная массива не определена, то array 
names вернет пустой список. Наличие списка имен индексов позволяет  
организовать перебор элементов массива в цикле ioreach.
</p>
<div class="org-src-container">
<pre class="src src-tcl">foreach index [array names arr pattern] { 
# Действия с использованием выражения arr($index) 
} 
</pre>
</div>

<p>
  Порядок следования имен, предоставляемых командой array names,  
зависит от особенностей внутреннего представления массива, в частности от 
структуры хэш-таблицы, с помощью которой реализуется массив. Диапазон 
возвращаемых имен можно ограничить, указав шаблон, которому должны 
соответствовать индексы. Шаблон поддерживается командой string match, 
которая была описана в главе 4.
</p>

<p>
  Для поочередной обработки элементов массива можно также использовать
команды поиска, описанные в табл. 8.1. Порядок следования элементов и
в этом случае остается произвольным, поэтому необходимо признать, что
применять для перебора команду foreach более удобно. Если в массиве
находится большое число элементов или если вам надо выполнять
обработку в течение длительного периода времени, предпочтительнее
использовать операции поиска в массиве. Описание различных операций,
реализуемых посредством команды array, приведено в табл. 8.1.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Таблица 8.1. Команда array</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">array exists переменная</td>
<td class="org-left">Возвращает значение 1, если переменная является массивом</td>
</tr>

<tr>
<td class="org-left">array get массив ?шаблон?</td>
<td class="org-left">Возвращает список, содержащий индексы и соответствующие им значения. С помощью шаблона задаются требуемые индексы. Если шаблон не указан, возвращаются все индексы и значения</td>
</tr>

<tr>
<td class="org-left">array names массив ?режим? ?шаблон?</td>
<td class="org-left">Возвращает список, содержащий все индексы массива, либо те из них, которые удовлетворяют шаблону. Режим определяет правила сравнения с шаблоном и задается с помощью опций -exact, -glob (значение по умолчанию) или -regexp</td>
</tr>

<tr>
<td class="org-left">array set массив список</td>
<td class="org-left">Инициализирует массив значениями из списка. Формат списка совпадает с данными, возвращаемыми в результате выполнения операции array get</td>
</tr>

<tr>
<td class="org-left">array size массив</td>
<td class="org-left">Возвращает число индексов, определенных в указанном массиве</td>
</tr>

<tr>
<td class="org-left">array unset массив ?шаблон?</td>
<td class="org-left">Удаляет элементы массива, соответствующие шаблону. Сравнение с шаблоном выполняется по тому же принципу, что и в команде glob. Если шаблон не задан, удаляется весь массив</td>
</tr>

<tr>
<td class="org-left">array startsearch массив</td>
<td class="org-left">Возвращает идентификатор поиска для массива</td>
</tr>

<tr>
<td class="org-left">array nextelement массив идентификатор</td>
<td class="org-left">Возвращает значение следующего элемента массива в поиске, идентифицируемом с помощью указанного идентификатора. Если элементы в поиске отсутствуют, возвращается пустая строка</td>
</tr>

<tr>
<td class="org-left">array anymore массив идентификатор</td>
<td class="org-left">Возвращает значение 1, если в поиске присутствуют элементы</td>
</tr>

<tr>
<td class="org-left">array donesearch мас сив идентификатор</td>
<td class="org-left">Завершает поиск, определяемый указанным идентификатором</td>
</tr>

<tr>
<td class="org-left">array statistics массив</td>
<td class="org-left">Возвращает сведения о хэш-таблице массива (Tcl 8.4)</td>
</tr>
</tbody>
</table>
</div>



<div id="outline-container-org17f7aa3" class="outline-3">
<h3 id="org17f7aa3"><span class="section-number-3">2.1.</span> Преобразование массивов в списки</h3>
<div class="outline-text-3" id="text-2-1">
<p>
  Для преобразования массивов в списки и списков в массивы  
используются соответственно команды array get и array set. Список, возвращаемый 
командой array get, содержит четное число элементов. В нем попеременно 
расположены индексы и значения. Первым элементом списка является  
индекс, а за ним следует значение соответствующего элемента массива и т.д. 
Такую же структуру должен иметь массив, передаваемый в качестве  
параметра команде array set.
</p>
<div class="org-src-container">
<pre class="src src-tcl">array set fruit { 
best kiwi 
worst peach 
ok banana 
} 
array get fruit 
=&gt; ok banana best kiwi worst peach 
</pre>
</div>

<p>
  Таким образом, становится очевидным еще один способ перебора  
содержимого массива - преобразование в список посредством команды array get, 
а затем использование команды foreach с двумя переменными.
</p>
<div class="org-src-container">
<pre class="src src-tcl">foreach {key value} [array get fruit] { 
# Ключевыми значениями являются ok, best и worst 
# Значением является название соответствующего продукта 
} 
</pre>
</div>
</div>
</div>

<div id="outline-container-org62ee344" class="outline-3">
<h3 id="org62ee344"><span class="section-number-3">2.2.</span> Передача имен массивов</h3>
<div class="outline-text-3" id="text-2-2">
<p>
  Команда upvar позволяет работать с массивами. Вы можете передать 
процедуре имя массива и использовать команду upvar для получения  
косвенной ссылки на переменную массива в той области видимости, из которой 
осуществляется вызов процедуры. Данный подход демонстрирует код  
программы, приведенный в листинге 8.4. Эта программа осуществляет  
инвертирование массива. Как и в случае команды array names, вы можете задать 
для array get шаблон и ограничить набор возвращаемых значений. Команда 
upvar используется потому, что процедуре Arraylnvert передается имя  
массива. В момент вызова Arraylnvert массив, содержащий инвертированные 
значения, может отсутствовать.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Листинг 8.4. Процедура Arraylnvert осуществляет инвертирование массива</label><pre class="src src-tcl" id="orgcb18c9a">proc Arraylnvert {arrName inverseName {pattern *}} {
    upvar $arrName array $inverseName inverse
    foreach {index value} [array get array $pattern] {
        set inverse($value) $index } } 
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1b97858" class="outline-2">
<h2 id="org1b97858"><span class="section-number-2">3.</span> Создание структур данных на базе массивов</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgc01fa51" class="outline-3">
<h3 id="orgc01fa51"><span class="section-number-3">3.1.</span> 0</h3>
<div class="outline-text-3" id="text-3-1">
<p>
  В данном разделе описываются некоторые структуры данных, которые
можно сформировать на базе Tcl-массивов. Здесь же реализованы
процедуры, обеспечивающие доступ к этим структурам. Создание
интерфейса к структуре данных в виде процедуры считается хорошим
стилем программирования. Это позволяет скрыть от пользователя детали
реализации структуры и защитить саму структуру от некорректных
действий.
</p>

<p>
  Для хранения взаимосвязанных переменных рекомендуется использовать
массивы.
</p>

<p>
  Массивы удобно использовать для объединения взаимосвязанных 
переменных в один модуль. В этом случае массив выполняет ту 
же функцию, что и запись в других языках программирования. 
При объединении переменных в массив имя массива выполняет роль 
имени модуля. При этом исключаются конфликты между  
различными модулями. Для того чтобы обеспечить доступ процедуры ко 
всем переменным модуля, достаточно одного выражения global. 
Для управления набором массивов можно использовать переменную 
upvar. Пример такого применения показан в листинге 8.9.
</p>
</div>
</div>

<div id="outline-container-org30c5ecf" class="outline-3">
<h3 id="org30c5ecf"><span class="section-number-3">3.2.</span> Простые записи</h3>
<div class="outline-text-3" id="text-3-2">
<p>
  Предположим, что в вашем распоряжении есть база данных с  
информацией о сотрудниках. Ниже приведен ряд примеров, демонстрирующих  
различные способы хранения имен сотрудников, их идентификационных кодов и  
номеров телефонов. В каждом из примеров реализованы запись Emp<sub>AddRecord</sub>, 
предназначенная для хранения данных, и функция для доступа к данным. 
Например, функция Emp<sub>Manager</sub> возвращает информацию о сотруднике.  
Если доступ к полям записи осуществляется с помощью простой процедуры, 
реализация этой записи остается скрытой от пользователя и автор  
разработки получает возможность изменять ее структуру; при этом программы, 
работающие с записью, остаются неизменными. В листинге 8.5 для хранения 
полей записи используются отдельные массивы. В качестве индекса каждого 
массива используется имя пользователя.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>Листинг 8.5. Использование массивов для создания записей (вариант 1)</label><pre class="src src-tcl" id="org2de410e">proc Emp_AddRecord {id name manager phone} {
    global employeelD employeeManager \
        employeePhone employeeName
    set employeeID($name) $id
    set employeeManager($name) $manager
    set employeePhone($name) $phone
    set employeeName($id) $name }

proc Emp_Manager {name} {
    global employeeManager
    return $employeeManager($name) }
</pre>
</div>

<p>
  Массив employeeName поддерживает дополнительные ключи для обращения
к базе. Он реализует отображение идентификационных номеров в имена.  В
результате пользователь, в распоряжении которого вместо имени
оказывается идентификационный код, получает возможность извлечь
требуемую информацию. В листинге 8.6 реализована та же база данных, но
вся информация хранится в одном массиве, а структура индексов
оказывается более сложной.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>Листинг 8.6. Использование массивов для создания записей (вариант 2)</label><pre class="src src-tcl" id="orge789192">proc Emp_AddRecord {id name manager phone} { 
global employee 
set employee(id,$name) $id 
set employee(manager,$name) $manager 
set employee(phone,$name) $phone 
set employee(name,$id) $name 
} 
proc Emp_Manager {name} { 
global employee 
return $employee(manager,$name) 
}
</pre>
</div>

<p>
  Еще один подход к решению данной задачи реализован в листинге 8.7.
Каждый элемент массива представляет собой список полей, а для доступа
к требуемому полю используется команда 1 index. Здесь обращение по
идентификационному коду осуществляется по-другому. Если имена
отличаются от идентификационных кодов, можно организовать перекрестные
ссылки внутри одного массива.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>Листинг 8.7. Использование массивов для создания записей (вариант 3)</label><pre class="src src-tcl" id="orgd9d6343">proc Emp_AddRecord {id name manager phone} {
    global employee
    set employee($name) [list $name $id $manager $phone]
    set employee($id) $name }

proc Emp_Manager {name} {
    global employee
    return [lindex $employee($name) 2] }
</pre>
</div>

<p>
  Различия между данными подходами несущественны. Конкретный выбор
зависит от вкуса разработчика. Работать с одним массивом удобнее, так
как при этом осуществляется управление меньшим числом переменных.
Использование списков для хранения полей эффективно с точки зрения
затрат памяти, поскольку число элементов массива сокращается. Однако
при этом необходимо поддерживать смещения lindex. В любом случае
реализация структуры должна быть скрыта от пользователей, а интерфейс
должен быть реализован с помощью процедур.
</p>
</div>
</div>
<div id="outline-container-orgd423732" class="outline-3">
<h3 id="orgd423732"><span class="section-number-3">3.3.</span> Стек</h3>
<div class="outline-text-3" id="text-3-3">
<p>
  Стек можно реализовать как на основе списка, так и на основе массива. 
При использовании списка накладные расходы, связанные с записью и  
извлечением данных, пропорциональны размеру стека. Если в стеке  
содержится небольшое количество элементов, с подобным эффектом можно мириться. 
При увеличении объема стека следует подумать о том, чтобы перейти к  
работе с массивом.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>Листинг 8.8. Реализация стека на базе списка</label><pre class="src src-tcl" id="orgb754798">proc Push { stack value } {
    upvar $stack list
    lappend list $value }

proc Pop { stack } {
    upvar $stack list
    set value [lindex $list end]
    set list [lrange $list 0 [expr [llength $list]-2]]
    return $value }
</pre>
</div>

<p>
  В примерах, приведенных в листингах 8.8 и 8.9, имя стека передается
как параметр, а команда upvar используется для преобразования его в
структуру, используемую в качестве стека. В листинге 8.8 для создания
стека применяется список, а в листинге 8.9 — массив. Разработчик,
использующий стек в своей программе, не обязан знать особенности его
реализации.
</p>

<p>
  Если стек реализован на основе массива, один элемент массива
используется для хранения информации об объеме стека, а в остальных
элементах содержатся конкретные значения. Процедуры Push и Pop
проверяют, существует ли указанный массив, используя для этого команду
info exists.  Когда процедура Push первый раз присваивает значение
S(top), она создает переменную массива в области видимости вызывающего
кода. Индексы массива используются двумя способами. В элементе,
определяемом индексом top.  хранятся сведения о глубине
стека. Остальные индексы — это числа. Таким образом, выражение
$S($S(top)) ссылается на вершину стека.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>Листинг 8.9. Реализация стека на базе массива</label><pre class="src src-tcl" id="org71d405f">proc Push { stack value } {
    upvar $stack S
    if {![info exists S(top)]} {
        set S(top) 0
    }
    set S($S(top)) $value
    incr S(top) }
proc Pop { stack } {
    upvar $stack S
    if {![info exists S(top)]} {
        return {}
    }
    if {$S(top) == 0} {
        return {}
    } else {
        incr S(top) -1
        set x $S($S(top))
        unset S($S(top))
        return $x } } 
</pre>
</div>
</div>
</div>

<div id="outline-container-org60c09e4" class="outline-3">
<h3 id="org60c09e4"><span class="section-number-3">3.4.</span> Список массивов</h3>
<div class="outline-text-3" id="text-3-4">
<p>
  Предположим, что у вас есть ряд массивов, в каждом из которых
хранятся некоторые данные. Предположим также, что вам надо упорядочить
наборы данных. Один из способов решения этой задачи состоит в создании
Tcl-сниска, содержащего имя каждого массива. В листинге 8.10
определены процедура RecordAppend, предназначенная для добавления
массива к списку, и функция-итератор Recordlterate, которая позволяет
применить некоторый сценарий к каждому массиву. В итераторе
присутствует команда upvar.  С ее помощью создается псевдоним для
текущего массива. Для запуска сценария используется команда eval,
которая будет подробно описана в главе 10.  Tcl-команды, содержащиеся
в сценарии script, ссылаются па массив с именем data.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>Листинг 8.10. Поддержка списка массивов</label><pre class="src src-tcl" id="orga6b4c8b">proc RecordAppend {listName arrayName} {
    upvar $listName list
    lappend list $arrayName }

proc Recordlterate {listName script} {
    upvar $listName list
    foreach arrayName $list {
        upvar #0 $arrayName data
        eval $script }} 
</pre>
</div>

<p>
  Существуют и другие способы создания списка записей. Например, такую
структуру можно реализовать, включая в состав каждой из записей ссылку
на предшествующую и последующую запись. В листинге 8.11 показаны
функция вставки и функция-итератор, которые созданы этим
способом. Команда upvar создает псевдоним data для текущего
массива. Цикл оканчивается тогда, когда выясняется, что следующий
массив отсутствует. Создание псевдонима для несуществующей переменной
&#x2013; вполне допустимая операция.  Допустимо также изменять целевой
объект для псевдонима, созданного с помощью команды upvar. В данном
примере не учтена лишь необходимость инициализации первой записи, и
для нее элемент next является пустой строкой.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>Листинг 8.11. Поддержка списка массивов</label><pre class="src src-tcl" id="org9007868">proc Recordlnsert {recName afterThis} {
    upvar $recName record $afterThis after
    set record(next) $after(next)
    set after(next) $recName }

proc Recordlterate {firstRecord body} {
    upvar #0 $firstRecord data
    while {[info exists data]} {
        eval $body
        upvar #0 $data(next) data }} 
</pre>
</div>
</div>
</div>

<div id="outline-container-org3f1ff60" class="outline-3">
<h3 id="org3f1ff60"><span class="section-number-3">3.5.</span> Простая база данных</h3>
<div class="outline-text-3" id="text-3-5">
<p>
  Предположим, вам надо управлять набором записей, в каждой из которых 
содержится большой объем данных, а для поиска требуемой информации 
используются ключевые значения. Процедура добавления записи выглядит 
следующим образом:
</p>

<p>
Db<sub>Insert</sub> keylist datablob
</p>

<p>
где datablob — это имя, значение списка, пригодное для передачи набору
массивов, текст либо двоичные данные. Реализация Db<sub>Insert</sub> может
выглядеть следующим образом:
</p>
<div class="org-src-container">
<pre class="src src-tcl">foreach key $keylist {
    lappend Db($key) $datablob } 
</pre>
</div>

<p>
  При использовании данного подхода возникает проблема: информация, 
соответствующая каждому ключу, дублируется. Поэтому для решения этой 
задачи предпочтительнее использовать два массива. В одном из них  
содержатся все данные, помеченные простыми идентификаторами, которые  
генерируются автоматически. Во втором массиве хранится информация о связи 
между ключами и данными. Описанный подход иллюстрируется примером, 
показанным в листинге 8.12. Здесь используется механизм пространств имен, 
который будет рассмотрен в главе 14. Данный пример также показывает,  
насколько легко можно выводить структуры данных, записывая команды array 
set в файл, а затем загружать их с помощью команды source.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>Листинг 8.12. Простая база данных, предназначенная для хранения в памяти</label><pre class="src src-tcl" id="org7277dc6">namespace eval db {
    variable data ;# Массив данных
    variable uid 0 ;# Индекс
    variable index ;# Перекрестные ссылки }

proc db::insert {keylist datablob} {
    variable data
    184
    Часть I. Основы Tcl
    variable uid
    variable index
    set data([incr uid]) $datablob
    foreach key $keylist {
        lappend index($key) $uid }}

proc db::get {key} {
    variable data
    variable index
    set result {}
    if {![info exist index($key)]} {
        return {}
    }
    foreach uid $index($key) {
        lappend result $data($uid)
    }
    return $result }

proc db::save {filename} {
    variable uid
    set out [open $filename w]
    puts $out [list namespace eval db \
                   [list variable uid $uid]]
    puts $out [list array set db::data [array get db::data]]
    puts $out [list array set db::index [array get db::index]]
    close $out }

proc db::load {filename} {
    source $filename }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc35e8ae" class="outline-3">
<h3 id="orgc35e8ae"><span class="section-number-3">3.6.</span> Альтернативы использованию массивов</h3>
<div class="outline-text-3" id="text-3-6">
<p>
  Несмотря на то что Tcl-массивы являются структурами общего
назначения и обеспечивают достаточно высокий уровень гибкости, их
нельзя рассматривать как универсальное решение всех задач, связанных с
обработкой данных. Если вам надо создать сложные структуры данных,
имеет смысл использовать средства, реализованные в библиотеках С и
создать для них интерфейс с помощью команд Tcl. Так, например, в главе
47 будет рассмотрена структура данных blob, реализованная на С. Вы
также можете использовать генератор кода SWIG, который позволяет
формировать интерфейс к С API посредством Tcl-команд. Информация о
SWIG приведена по адресу <a href="http://www.swig.org">http://www.swig.org</a>.
</p>

<p>
  При работе с Tcl можно использовать встроенную базу данных Metakit.
Она предоставляет гораздо больше возможностей, чем "плоская"' база,
реализованная в данной главе, однако Metakit все же не является базой
данных SQL. База Metakit входит в состав Tclkit. Вы также можете
использовать ее совместно с расширением mk4Tcl. Tclkit и Metakit
описываются в главе 22.</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-02-06 Вт 21:54</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
